//
// Generated by Bluespec Compiler, version 2017.07.A (build 1da80f1, 2017-07-21)
//
// On Sat Apr 20 18:30:10 BST 2019
//
//
// Ports:
// Name                         I/O  size props
// RDY_server_reset_request_put   O     1 reg
// RDY_server_reset_response_get  O     1
// read_rs1                       O   129
// read_rs1_port2                 O   129
// read_rs2                       O   129
// is_busy                        O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// read_rs1_rs1                   I     5
// read_rs1_port2_rs1             I     5
// read_rs2_rs2                   I     5
// write_rd_rd                    I     5
// write_rd_rd_val                I   129
// write_rd_int_rd                I     5
// write_rd_int_rd_val            I    64
// clear_quarter_qid              I     2 reg
// clear_quarter_mask             I     8 reg
// EN_server_reset_request_put    I     1
// EN_server_reset_response_get   I     1
// EN_write_rd                    I     1
// EN_write_rd_int                I     1
// EN_clear_quarter               I     1
//
// Combinational paths from inputs to outputs:
//   read_rs1_rs1 -> read_rs1
//   read_rs1_port2_rs1 -> read_rs1_port2
//   read_rs2_rs2 -> read_rs2
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkGPR_RegFile(CLK,
		     RST_N,

		     EN_server_reset_request_put,
		     RDY_server_reset_request_put,

		     EN_server_reset_response_get,
		     RDY_server_reset_response_get,

		     read_rs1_rs1,
		     read_rs1,

		     read_rs1_port2_rs1,
		     read_rs1_port2,

		     read_rs2_rs2,
		     read_rs2,

		     write_rd_rd,
		     write_rd_rd_val,
		     EN_write_rd,

		     write_rd_int_rd,
		     write_rd_int_rd_val,
		     EN_write_rd_int,

		     clear_quarter_qid,
		     clear_quarter_mask,
		     EN_clear_quarter,

		     is_busy);
  input  CLK;
  input  RST_N;

  // action method server_reset_request_put
  input  EN_server_reset_request_put;
  output RDY_server_reset_request_put;

  // action method server_reset_response_get
  input  EN_server_reset_response_get;
  output RDY_server_reset_response_get;

  // value method read_rs1
  input  [4 : 0] read_rs1_rs1;
  output [128 : 0] read_rs1;

  // value method read_rs1_port2
  input  [4 : 0] read_rs1_port2_rs1;
  output [128 : 0] read_rs1_port2;

  // value method read_rs2
  input  [4 : 0] read_rs2_rs2;
  output [128 : 0] read_rs2;

  // action method write_rd
  input  [4 : 0] write_rd_rd;
  input  [128 : 0] write_rd_rd_val;
  input  EN_write_rd;

  // action method write_rd_int
  input  [4 : 0] write_rd_int_rd;
  input  [63 : 0] write_rd_int_rd_val;
  input  EN_write_rd_int;

  // action method clear_quarter
  input  [1 : 0] clear_quarter_qid;
  input  [7 : 0] clear_quarter_mask;
  input  EN_clear_quarter;

  // value method is_busy
  output is_busy;

  // signals for module outputs
  wire [128 : 0] read_rs1, read_rs1_port2, read_rs2;
  wire RDY_server_reset_request_put, RDY_server_reset_response_get, is_busy;

  // register rg_base
  reg [1 : 0] rg_base;
  wire [1 : 0] rg_base$D_IN;
  wire rg_base$EN;

  // register rg_mask
  reg [7 : 0] rg_mask;
  wire [7 : 0] rg_mask$D_IN;
  wire rg_mask$EN;

  // register rg_state
  reg [1 : 0] rg_state;
  reg [1 : 0] rg_state$D_IN;
  wire rg_state$EN;

  // register rg_sub
  reg [2 : 0] rg_sub;
  wire [2 : 0] rg_sub$D_IN;
  wire rg_sub$EN;

  // ports of submodule f_reset_rsps
  wire f_reset_rsps$CLR,
       f_reset_rsps$DEQ,
       f_reset_rsps$EMPTY_N,
       f_reset_rsps$ENQ,
       f_reset_rsps$FULL_N;

  // ports of submodule regfile
  reg [128 : 0] regfile$D_IN;
  reg [4 : 0] regfile$ADDR_IN;
  wire [128 : 0] regfile$D_OUT_1, regfile$D_OUT_2, regfile$D_OUT_3;
  wire [4 : 0] regfile$ADDR_1,
	       regfile$ADDR_2,
	       regfile$ADDR_3,
	       regfile$ADDR_4,
	       regfile$ADDR_5;
  wire regfile$WE;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_fastclear,
       CAN_FIRE_RL_rl_reset_loop,
       CAN_FIRE_RL_rl_reset_start,
       CAN_FIRE_clear_quarter,
       CAN_FIRE_server_reset_request_put,
       CAN_FIRE_server_reset_response_get,
       CAN_FIRE_write_rd,
       CAN_FIRE_write_rd_int,
       WILL_FIRE_RL_rl_fastclear,
       WILL_FIRE_RL_rl_reset_loop,
       WILL_FIRE_RL_rl_reset_start,
       WILL_FIRE_clear_quarter,
       WILL_FIRE_server_reset_request_put,
       WILL_FIRE_server_reset_response_get,
       WILL_FIRE_write_rd,
       WILL_FIRE_write_rd_int;

  // inputs to muxes for submodule ports
  wire [128 : 0] MUX_regfile$upd_2__VAL_3;
  wire [4 : 0] MUX_regfile$upd_1__VAL_1;
  wire [2 : 0] MUX_rg_sub$write_1__VAL_2;
  wire MUX_regfile$upd_1__SEL_1,
       MUX_regfile$upd_1__SEL_2,
       MUX_regfile$upd_1__SEL_3,
       MUX_rg_state$write_1__SEL_3;

  // remaining internal signals
  wire rg_mask_BIT_rg_sub___d7;

  // action method server_reset_request_put
  assign RDY_server_reset_request_put = f_reset_rsps$FULL_N ;
  assign CAN_FIRE_server_reset_request_put = f_reset_rsps$FULL_N ;
  assign WILL_FIRE_server_reset_request_put = EN_server_reset_request_put ;

  // action method server_reset_response_get
  assign RDY_server_reset_response_get =
	     rg_state == 2'd2 && f_reset_rsps$EMPTY_N ;
  assign CAN_FIRE_server_reset_response_get =
	     rg_state == 2'd2 && f_reset_rsps$EMPTY_N ;
  assign WILL_FIRE_server_reset_response_get = EN_server_reset_response_get ;

  // value method read_rs1
  assign read_rs1 =
	     { read_rs1_rs1 != 5'd0 && regfile$D_OUT_3[128],
	       (read_rs1_rs1 == 5'd0) ? 128'd0 : regfile$D_OUT_3[127:0] } ;

  // value method read_rs1_port2
  assign read_rs1_port2 =
	     { read_rs1_port2_rs1 != 5'd0 && regfile$D_OUT_2[128],
	       (read_rs1_port2_rs1 == 5'd0) ?
		 128'd0 :
		 regfile$D_OUT_2[127:0] } ;

  // value method read_rs2
  assign read_rs2 =
	     { read_rs2_rs2 != 5'd0 && regfile$D_OUT_1[128],
	       (read_rs2_rs2 == 5'd0) ? 128'd0 : regfile$D_OUT_1[127:0] } ;

  // action method write_rd
  assign CAN_FIRE_write_rd = 1'd1 ;
  assign WILL_FIRE_write_rd = EN_write_rd ;

  // action method write_rd_int
  assign CAN_FIRE_write_rd_int = 1'd1 ;
  assign WILL_FIRE_write_rd_int = EN_write_rd_int ;

  // action method clear_quarter
  assign CAN_FIRE_clear_quarter = 1'd1 ;
  assign WILL_FIRE_clear_quarter = EN_clear_quarter ;

  // value method is_busy
  assign is_busy = rg_state != 2'd2 ;

  // submodule f_reset_rsps
  FIFO20 #(.guarded(32'd1)) f_reset_rsps(.RST(RST_N),
					 .CLK(CLK),
					 .ENQ(f_reset_rsps$ENQ),
					 .DEQ(f_reset_rsps$DEQ),
					 .CLR(f_reset_rsps$CLR),
					 .FULL_N(f_reset_rsps$FULL_N),
					 .EMPTY_N(f_reset_rsps$EMPTY_N));

  // submodule regfile
  RegFile #(.addr_width(32'd5),
	    .data_width(32'd129),
	    .lo(5'h0),
	    .hi(5'd31)) regfile(.CLK(CLK),
				.ADDR_1(regfile$ADDR_1),
				.ADDR_2(regfile$ADDR_2),
				.ADDR_3(regfile$ADDR_3),
				.ADDR_4(regfile$ADDR_4),
				.ADDR_5(regfile$ADDR_5),
				.ADDR_IN(regfile$ADDR_IN),
				.D_IN(regfile$D_IN),
				.WE(regfile$WE),
				.D_OUT_1(regfile$D_OUT_1),
				.D_OUT_2(regfile$D_OUT_2),
				.D_OUT_3(regfile$D_OUT_3),
				.D_OUT_4(),
				.D_OUT_5());

  // rule RL_rl_reset_start
  assign CAN_FIRE_RL_rl_reset_start = rg_state == 2'd0 ;
  assign WILL_FIRE_RL_rl_reset_start = CAN_FIRE_RL_rl_reset_start ;

  // rule RL_rl_reset_loop
  assign CAN_FIRE_RL_rl_reset_loop = rg_state == 2'd1 ;
  assign WILL_FIRE_RL_rl_reset_loop = CAN_FIRE_RL_rl_reset_loop ;

  // rule RL_rl_fastclear
  assign CAN_FIRE_RL_rl_fastclear = rg_state == 2'd3 ;
  assign WILL_FIRE_RL_rl_fastclear =
	     CAN_FIRE_RL_rl_fastclear && !EN_write_rd_int && !EN_write_rd ;

  // inputs to muxes for submodule ports
  assign MUX_regfile$upd_1__SEL_1 =
	     WILL_FIRE_RL_rl_fastclear && rg_mask_BIT_rg_sub___d7 ;
  assign MUX_regfile$upd_1__SEL_2 = EN_write_rd && write_rd_rd != 5'd0 ;
  assign MUX_regfile$upd_1__SEL_3 =
	     EN_write_rd_int && write_rd_int_rd != 5'd0 ;
  assign MUX_rg_state$write_1__SEL_3 =
	     WILL_FIRE_RL_rl_fastclear && rg_sub == 3'd7 ;
  assign MUX_regfile$upd_1__VAL_1 = { rg_base, rg_sub } ;
  assign MUX_regfile$upd_2__VAL_3 = { 65'd0, write_rd_int_rd_val } ;
  assign MUX_rg_sub$write_1__VAL_2 = rg_sub + 3'd1 ;

  // register rg_base
  assign rg_base$D_IN = clear_quarter_qid ;
  assign rg_base$EN = EN_clear_quarter ;

  // register rg_mask
  assign rg_mask$D_IN = clear_quarter_mask ;
  assign rg_mask$EN = EN_clear_quarter ;

  // register rg_state
  always@(EN_clear_quarter or
	  EN_server_reset_request_put or
	  MUX_rg_state$write_1__SEL_3 or
	  WILL_FIRE_RL_rl_reset_loop or WILL_FIRE_RL_rl_reset_start)
  case (1'b1)
    EN_clear_quarter: rg_state$D_IN = 2'd3;
    EN_server_reset_request_put: rg_state$D_IN = 2'd0;
    MUX_rg_state$write_1__SEL_3 || WILL_FIRE_RL_rl_reset_loop:
	rg_state$D_IN = 2'd2;
    WILL_FIRE_RL_rl_reset_start: rg_state$D_IN = 2'd1;
    default: rg_state$D_IN = 2'b10 /* unspecified value */ ;
  endcase
  assign rg_state$EN =
	     WILL_FIRE_RL_rl_fastclear && rg_sub == 3'd7 ||
	     EN_server_reset_request_put ||
	     WILL_FIRE_RL_rl_reset_start ||
	     WILL_FIRE_RL_rl_reset_loop ||
	     EN_clear_quarter ;

  // register rg_sub
  assign rg_sub$D_IN = EN_clear_quarter ? 3'b0 : MUX_rg_sub$write_1__VAL_2 ;
  assign rg_sub$EN = WILL_FIRE_RL_rl_fastclear || EN_clear_quarter ;

  // submodule f_reset_rsps
  assign f_reset_rsps$ENQ = EN_server_reset_request_put ;
  assign f_reset_rsps$DEQ = EN_server_reset_response_get ;
  assign f_reset_rsps$CLR = 1'b0 ;

  // submodule regfile
  assign regfile$ADDR_1 = read_rs2_rs2 ;
  assign regfile$ADDR_2 = read_rs1_port2_rs1 ;
  assign regfile$ADDR_3 = read_rs1_rs1 ;
  assign regfile$ADDR_4 = 5'h0 ;
  assign regfile$ADDR_5 = 5'h0 ;
  always@(MUX_regfile$upd_1__SEL_1 or
	  MUX_regfile$upd_1__VAL_1 or
	  MUX_regfile$upd_1__SEL_2 or
	  write_rd_rd or MUX_regfile$upd_1__SEL_3 or write_rd_int_rd)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_regfile$upd_1__SEL_1: regfile$ADDR_IN = MUX_regfile$upd_1__VAL_1;
      MUX_regfile$upd_1__SEL_2: regfile$ADDR_IN = write_rd_rd;
      MUX_regfile$upd_1__SEL_3: regfile$ADDR_IN = write_rd_int_rd;
      default: regfile$ADDR_IN = 5'b01010 /* unspecified value */ ;
    endcase
  end
  always@(MUX_regfile$upd_1__SEL_1 or
	  MUX_regfile$upd_1__SEL_2 or
	  write_rd_rd_val or
	  MUX_regfile$upd_1__SEL_3 or MUX_regfile$upd_2__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_regfile$upd_1__SEL_1: regfile$D_IN = 129'd0;
      MUX_regfile$upd_1__SEL_2: regfile$D_IN = write_rd_rd_val;
      MUX_regfile$upd_1__SEL_3: regfile$D_IN = MUX_regfile$upd_2__VAL_3;
      default: regfile$D_IN =
		   129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign regfile$WE =
	     WILL_FIRE_RL_rl_fastclear && rg_mask_BIT_rg_sub___d7 ||
	     EN_write_rd && write_rd_rd != 5'd0 ||
	     EN_write_rd_int && write_rd_int_rd != 5'd0 ;

  // remaining internal signals
  assign rg_mask_BIT_rg_sub___d7 = rg_mask[rg_sub] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_state <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (rg_state$EN) rg_state <= `BSV_ASSIGNMENT_DELAY rg_state$D_IN;
      end
    if (rg_base$EN) rg_base <= `BSV_ASSIGNMENT_DELAY rg_base$D_IN;
    if (rg_mask$EN) rg_mask <= `BSV_ASSIGNMENT_DELAY rg_mask$D_IN;
    if (rg_sub$EN) rg_sub <= `BSV_ASSIGNMENT_DELAY rg_sub$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_base = 2'h2;
    rg_mask = 8'hAA;
    rg_state = 2'h2;
    rg_sub = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkGPR_RegFile

